const cron = require('node-cron');
const axios = require('axios');
const { getDatabase } = require('../database/init');

let updateCheckerInterval = null;

function startUpdateChecker() {
  const checkInterval = process.env.CHECK_INTERVAL_HOURS || 6;
  
  // V√©rifier les mises √† jour selon l'intervalle configur√©
  updateCheckerInterval = cron.schedule(`0 */${checkInterval} * * *`, async () => {
    console.log('üîÑ V√©rification des mises √† jour...');
    await checkAllApplicationsForUpdates();
  }, {
    scheduled: false
  });

  updateCheckerInterval.start();
  console.log(`‚úÖ V√©rificateur de mises √† jour d√©marr√© (v√©rification toutes les ${checkInterval}h)`);

  // Effectuer une v√©rification imm√©diate apr√®s 10 secondes
  setTimeout(checkAllApplicationsForUpdates, 10000);
}

function stopUpdateChecker() {
  if (updateCheckerInterval) {
    updateCheckerInterval.stop();
    console.log('‚èπÔ∏è V√©rificateur de mises √† jour arr√™t√©');
  }
}

async function checkAllApplicationsForUpdates() {
  const db = getDatabase();
  
  db.all('SELECT * FROM applications', async (err, applications) => {
    if (err) {
      console.error('Erreur lors de la r√©cup√©ration des applications:', err);
      return;
    }

    console.log(`üì± V√©rification de ${applications.length} applications...`);

    for (const application of applications) {
      try {
        await checkApplicationForUpdates(application);
        // Attendre un peu entre chaque v√©rification pour √©viter de surcharger les APIs
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        console.error(`Erreur lors de la v√©rification de ${application.name}:`, error.message);
      }
    }

    console.log('‚úÖ V√©rification des mises √† jour termin√©e');
  });
}

async function checkApplicationForUpdates(application) {
  const db = getDatabase();
  
  try {
    const updateInfo = await fetchLatestVersion(application);
    
    if (!updateInfo.latestVersion) {
      console.warn(`‚ö†Ô∏è Impossible de r√©cup√©rer la version pour ${application.name}`);
      return;
    }

    const updateAvailable = isUpdateAvailable(
      application.current_version,
      application.latest_version,
      updateInfo.latestVersion
    );

    // Mettre √† jour l'application dans la base de donn√©es
    db.run(
      `UPDATE applications 
       SET latest_version = ?, update_available = ?, last_check = CURRENT_TIMESTAMP 
       WHERE id = ?`,
      [updateInfo.latestVersion, updateAvailable ? 1 : 0, application.id],
      (err) => {
        if (err) {
          console.error(`Erreur lors de la mise √† jour de ${application.name}:`, err);
        }
      }
    );

    // Si une nouvelle version est d√©tect√©e, l'ajouter √† l'historique et cr√©er une alerte
    if (updateAvailable && updateInfo.latestVersion !== application.latest_version) {
      // Ajouter √† l'historique
      db.run(
        'INSERT INTO update_history (application_id, old_version, new_version) VALUES (?, ?, ?)',
        [application.id, application.latest_version || application.current_version, updateInfo.latestVersion],
        (err) => {
          if (err) {
            console.error('Erreur lors de l\'ajout √† l\'historique:', err);
          }
        }
      );

      // Cr√©er une alerte
      await createUpdateAlert(application, updateInfo.latestVersion);
      
      console.log(`üÜï Nouvelle version disponible pour ${application.name}: ${updateInfo.latestVersion}`);
    } else {
      console.log(`‚úÖ ${application.name}: √† jour (${updateInfo.latestVersion})`);
    }

  } catch (error) {
    console.error(`‚ùå Erreur lors de la v√©rification de ${application.name}:`, error.message);
    
    // Marquer la derni√®re v√©rification m√™me en cas d'erreur
    db.run(
      'UPDATE applications SET last_check = CURRENT_TIMESTAMP WHERE id = ?',
      [application.id]
    );
  }
}

async function fetchLatestVersion(application) {
  const timeout = parseInt(process.env.DEFAULT_TIMEOUT) || 10000;
  
  switch (application.provider) {
    case 'github':
      return await fetchGitHubVersion(application.repository, timeout);
    
    case 'dockerhub':
      return await fetchDockerHubVersion(application.image, timeout);
    
    case 'api':
      return await fetchApiVersion(application.api_url, timeout);
    
    default:
      throw new Error(`Provider non support√©: ${application.provider}`);
  }
}

async function fetchGitHubVersion(repository, timeout) {
  try {
    const response = await axios.get(
      `https://api.github.com/repos/${repository}/releases/latest`,
      { 
        timeout,
        headers: {
          'User-Agent': 'CheckUp-Monitor/1.0'
        }
      }
    );

    return {
      latestVersion: response.data.tag_name,
      releaseDate: response.data.published_at,
      releaseNotes: response.data.body
    };

  } catch (error) {
    if (error.response && error.response.status === 404) {
      // Essayer de r√©cup√©rer les tags si pas de releases
      try {
        const tagsResponse = await axios.get(
          `https://api.github.com/repos/${repository}/tags`,
          { 
            timeout,
            headers: {
              'User-Agent': 'CheckUp-Monitor/1.0'
            }
          }
        );

        if (tagsResponse.data && tagsResponse.data.length > 0) {
          return {
            latestVersion: tagsResponse.data[0].name,
            releaseDate: null,
            releaseNotes: null
          };
        }
      } catch (tagsError) {
        throw new Error(`Impossible de r√©cup√©rer les tags GitHub: ${tagsError.message}`);
      }
    }
    
    throw new Error(`Erreur GitHub API: ${error.message}`);
  }
}

async function fetchDockerHubVersion(image, timeout) {
  try {
    // S√©parer le namespace/image si n√©cessaire
    const imageParts = image.includes('/') ? image : `library/${image}`;
    
    const response = await axios.get(
      `https://registry.hub.docker.com/v2/repositories/${imageParts}/tags/?page_size=25&ordering=-last_updated`,
      { timeout }
    );

    if (response.data && response.data.results && response.data.results.length > 0) {
      // Filtrer les tags pour √©viter les tags de d√©veloppement
      const validTags = response.data.results.filter(tag => {
        const tagName = tag.name;
        return !tagName.includes('dev') && 
               !tagName.includes('beta') && 
               !tagName.includes('alpha') && 
               !tagName.includes('rc') &&
               tagName !== 'latest';
      });

      const latestTag = validTags.length > 0 ? validTags[0] : response.data.results[0];

      return {
        latestVersion: latestTag.name,
        releaseDate: latestTag.last_updated,
        releaseNotes: null
      };
    }

    throw new Error('Aucun tag trouv√©');

  } catch (error) {
    throw new Error(`Erreur Docker Hub API: ${error.message}`);
  }
}

async function fetchApiVersion(apiUrl, timeout) {
  try {
    const response = await axios.get(apiUrl, { timeout });
    
    // Essayer diff√©rents formats de r√©ponse
    let version = null;
    
    if (response.data.version) {
      version = response.data.version;
    } else if (response.data.tag_name) {
      version = response.data.tag_name;
    } else if (response.data.latest) {
      version = response.data.latest;
    } else if (typeof response.data === 'string') {
      version = response.data;
    }

    if (!version) {
      throw new Error('Format de r√©ponse API non reconnu');
    }

    return {
      latestVersion: version,
      releaseDate: response.data.published_at || response.data.date || null,
      releaseNotes: response.data.notes || response.data.changelog || null
    };

  } catch (error) {
    throw new Error(`Erreur API personnalis√©e: ${error.message}`);
  }
}

function isUpdateAvailable(currentVersion, knownLatestVersion, newLatestVersion) {
  // Si pas de version actuelle d√©finie, consid√©rer qu'une mise √† jour est disponible
  if (!currentVersion && newLatestVersion) {
    return true;
  }

  // Si la nouvelle version est diff√©rente de la version connue et de la version actuelle
  if (newLatestVersion && 
      newLatestVersion !== currentVersion && 
      newLatestVersion !== knownLatestVersion) {
    return true;
  }

  return false;
}

function compareVersions(version1, version2) {
  // Fonction basique de comparaison de versions
  // Peut √™tre am√©lior√©e avec une biblioth√®que comme semver
  
  if (!version1 || !version2) {
    return 0;
  }

  // Nettoyer les versions (enlever v, V, etc.)
  const clean1 = version1.replace(/^[vV]/, '');
  const clean2 = version2.replace(/^[vV]/, '');

  // S√©parer par points
  const parts1 = clean1.split('.').map(part => parseInt(part.replace(/\D/g, '')) || 0);
  const parts2 = clean2.split('.').map(part => parseInt(part.replace(/\D/g, '')) || 0);

  // Comparer chaque partie
  const maxLength = Math.max(parts1.length, parts2.length);
  
  for (let i = 0; i < maxLength; i++) {
    const part1 = parts1[i] || 0;
    const part2 = parts2[i] || 0;
    
    if (part1 > part2) return 1;
    if (part1 < part2) return -1;
  }

  return 0;
}

async function createUpdateAlert(application, newVersion) {
  const db = getDatabase();
  
  // V√©rifier s'il y a d√©j√† une alerte pour cette application
  db.get(
    'SELECT id FROM alerts WHERE source_type = ? AND source_id = ? AND resolved = 0 AND type = ?',
    ['application', application.id, 'update_available'],
    (err, existingAlert) => {
      if (err) {
        console.error('Erreur lors de la v√©rification des alertes:', err);
        return;
      }

      if (!existingAlert) {
        const title = `Mise √† jour disponible: ${application.name}`;
        const message = `Une nouvelle version de ${application.name} est disponible: ${newVersion}`;

        db.run(
          'INSERT INTO alerts (type, title, message, severity, source_type, source_id) VALUES (?, ?, ?, ?, ?, ?)',
          ['update_available', title, message, 'info', 'application', application.id],
          (err) => {
            if (err) {
              console.error('Erreur lors de la cr√©ation de l\'alerte:', err);
            } else {
              console.log(`üîî Alerte cr√©√©e: ${title}`);
            }
          }
        );
      }
    }
  );
}

// Nettoyer l'ancien historique des mises √† jour (garder seulement 30 jours)
function cleanupUpdateHistory() {
  const db = getDatabase();
  
  db.run(
    'DELETE FROM update_history WHERE detected_at < datetime(\'now\', \'-30 days\')',
    (err) => {
      if (err) {
        console.error('Erreur lors du nettoyage de l\'historique:', err);
      } else {
        console.log('üßπ Ancien historique des mises √† jour nettoy√©');
      }
    }
  );
}

// Programmer le nettoyage hebdomadaire
cron.schedule('0 3 * * 0', cleanupUpdateHistory); // Tous les dimanches √† 3h du matin

module.exports = {
  startUpdateChecker,
  stopUpdateChecker,
  checkApplicationForUpdates,
  checkAllApplicationsForUpdates
};